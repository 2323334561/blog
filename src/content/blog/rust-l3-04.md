---
title: ownership 所有权
pubDatetime: 2024-09-30T10:30:00+08:00
author: shushunie
slug: rust-l3-04
description: ""
---

## 编程语言的内存管理机制

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：

- 垃圾回收机制(GC)
- 手动管理内存的分配和释放
- 通过所有权来管理内存

#### 手动管理

代表语言：C/C++

特点：

- 程序员通过 malloc 和 free （C）或 new 和 delete （C++）手动分配和释放内存
- 没有内置的垃圾回收机制

优点：

- 高效且灵活，适用于对性能要求极高的系统级编程

缺点：

- 容易出现内存泄漏、悬垂指针和缓冲区溢出等问题，需要非常小心的内存管理

#### 垃圾回收

代表语言：JavaScript、Java、Go

特点

- 浏览器和 Node.js 环境中均使用垃圾回收器（如V8引擎的垃圾回收器）
- 采用标记-清除（Mark-and-Sweep）、标记-压缩（Mark-and-Compact）分代回收等算法

优点：

- 自动内存管理，适合快速开发和运行在多平台上的应用

缺点：

- 垃圾回收机制在某些情况下可能导致性能问题，如UI线程停顿

#### 所有权系统

代表语言：Rust

特点：

- Rust使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全
- 通过借用（引用）机制来共享数据，同时保证数据竞争和悬垂指针的安全

优点：

- 在编译时保证内存安全，没有运行时开销
- 避免了数据竞争和悬垂指针

缺点：

- 需要程序员理解和遵循所有权和借用规则，学习曲线较陡

## 所有权规则

1. 每一个值都有一个所有者（owner）
2. 在任一时刻，值只能有一个所有者
3. 当所有者离开作用域（scope），值会被丟弃（drop）

#### 所有权转移

```rust
let x = 5;
let y = x;
```

这段代码并没有发生所有权的转移，原因很简单： 代码首先将 `5` 绑定到变量 `x`，接着**拷贝** `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过**自动拷贝**的方式来赋值的，都被存在栈中，完全无需在堆上分配内存

```rust
let s1 = String::from("hello");
let s2 = s1;
```

当变量离开作用域后，Rust 会自动调用 `drop` 函数并清理变量的堆内存。不过由于两个 `String` 变量指向了同一位置。这就有了一个问题：当 `s1` 和 `s2` 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 **二次释放（double free）** 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞

因此，Rust 这样解决问题：当 `s1` 被赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了

拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 `s1` 无效了，因此这个操作被称为 **移动(move)**，而不是浅拷贝

#### 函数传值与返回

将值传递给函数，一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
} // s 移出了作用域，但因为 s 的值已被移走，所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放
```

同样的，函数返回值也有所有权

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1
} // s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // 将返回值移动给调用它的函数
    let some_string = String::from("hello"); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}
```
