---
title: 智能指针
pubDatetime: 2024-10-9T16:43:00+08:00
author: shushunie
slug: rust-l4-01
description: ""
---

Rust 中指针的概念非常灵活，比如它可以是一个结构体类型，只要其中的一个字段存储其它类型实例的地址，然后对这个结构体实现一些 Rust 标准库里提供的 trait，就可以把它变成指针类型这种指针可以在传统指针的基础上添加一些额外信息，比如放在额外的一些字段中，也可以做一些额外操作，比如管理引用计数，资源自动回收等

String 和 Vec 就是一种智能指针，标准库代码中 String 和 Vec 都被定义为结构体

## Box<T> 堆对象分配

在Rust中，所有值默认都是栈上分配。通过创建`Box<T>`，使值在堆上分配，其指针本身在栈，指向的数据在堆。使用 `Box::new()` 可以创建一个 box 智能指针

使用没有实现 copy 语义的类型的变量创建 box 指针，它会将栈上的值强行拷贝一份并存入堆中。对于实现了 copy 的类型，使用 box 指针会发生所有权转移

#### 避免栈溢出

对于一些存放在栈上的数据，如果数据量很大，可以使用 box 指针避免栈溢出。例如存储一个非常大的数组

```rust
let large_data = Box::new([0; 10000]); // 1万个元素的数组
```

除此之外，大型变量的数据转移也可能导致栈溢出。例如大型数组赋值

```rust
fn main() {
    let x = [0u8; 4 * 1024 * 1024];
    print_len(x);
    println!("{}", x.len()) // 10
}

fn print_len(arr: [0u8; 4 * 1024 * 1024]) {
    println!("{}", arr.len()) // 10
}
```

第 2 行定义并初始化了一个类型为`[u8; 10]`的数组变量`x`，`x`会被分配到栈上。第 3 行调用`print_len`函数，参数 arr 的类型也是`[u8; 10]`。从`x`到`arr`的传参赋值是 Copy 语义，参数`arr`也会被分配到栈上，使用了两倍内存空间，这将在运行时触发栈溢出

如果使用 box 可以将数组存入栈中，这样进行变量赋值时只会在栈上将 box 指针的结构体拷贝，数组的实际内容在堆内存中保持不变

#### 递归数据结构

Rust 的编译器要求类型的大小在编译时必须是已知的，这样就将其默认分配到栈上。而递归类型的大小通常是未知的，例如下面的链表

```rust
enum List {
    Cons(i32, List), // Cons 表示链表节点，存储一个整数和另一个 List
    Nil,             // Nil 表示链表结束
}
```

这里，`List` 类型是递归的，因为 `Cons` 中的第二个字段又是 `List` 类型。但是这会产生问题：为了确定 `List` 的大小，Rust 需要知道它包含了多少层嵌套。但我们可以在声明 `List` 类型的变量时，创建任意个节点，从而导致 Rust 无法知道 List 类型的大小

```rust
enum List {
    Cons(i32, Box<List>), // 将递归部分放入 Box 中
    Nil,
}
```

使用 box，在栈上仅存储第一个节点，后续递归产生的节点将放入堆内存存储。对于 rust 编译器来讲，List 类型的大小在栈上只有一层，占用大小是可以确定的

### trait 相关

还没学到，这里不关注
